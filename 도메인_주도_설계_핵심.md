# 도메인 주도 설계 핵심
## 1장. 나에게 도메인 주도 설계는
### 전술적 설계
- 전술적 설계는 도메인 모델의 세부사항들을 그리기 위해 얇은 붓을 사용하는 것과 같다.
- 가장 중요한 도구 중 하나는 `Entity``와 `Value Object`를 알맞은 크기의 `Aggregate`으로 묶는 데 사용한느 `Aggregate 패턴`이다.
- DDD는 도메인을 최대한 명확한 방법으로 모델링하는 거셍 관한 것이다.
- 도메인 이벤트의 사용은 명확하게 모델링하는 것을 도와주면서, 도메인에 발생한 것에 대해 알아야 하는 내용을 시스템과 공유하는 것을 돕는다.
- 공유할 대상이 로컬의 바운디드 컨텍스트일 수도, 다른 원격의 바운디드 컨텍스트일 수도 있다.

## 5장. 애그리게잇과 전술적 설계
### 엔티티는 무엇인가?
- 엔티티는 독립적인 것이다.
- 각 엔티티는 같은 형태를 띠거나 다른 형태의 엔티티들과의 특성을 구별할 수 있는 고유한 식별성을 갖는다.
- 엔티티는 변할 수도 있고, 변하지 않을 수도 있다.
- 다른 모델링 수단들과 엔티티를 구분해주는 주 요인은 유일성, 즉 그것의 독립성에 있다.

### 값 객체는 무엇인가?
- 값 객체 또는 간단히 말해 값은 불변의 개념적 완전성을 모델링한다.
- 모델에서 값은 그야말로 값이다.
- 엔티티와 달리, 공유한 식별성이 없으며, 값 형태로 캡슐화된 속성을 비교함으로써 동일함이 결정된다.
- 그뿐만 아니라 값 객체가 어떤 것을 나타낸다기보다는 엔티티를 서술하고, 수량화하거나 측정하는데 사용된다.

### 애그리게잇이란?
- 각 애그리게잇은 1개 이상의 `엔티티`로 구성되고, 그 중 한 엔티티는 `애그리게잇 루트`라고 부른다. 또한, 그 구성에 `값 객체`를 포할 수 있다.

- 각 애그리게잇의 루트 엔티티는 애그리게잇 안의 다른 모든 요소를 소유한다. (루트 엔티티의 명칭은 애그리게잇의 개념적 명칭이다.)
- 애그리게잇이 모델링하는 개념적 완전성을 적절하게 표현할 수 있는 명칭으로 루트 엔티티 명칭을 정의해야 한다.

- 각 애그리게잇은 일관성 있는 트랜잭션 경계를 형성한다.
- 이것은 트랜잭션 제어가 데이터베이스에 커밋될 떄, 한 어그리게잇 내의 모든 구성 요소는 반드시 비즈니스 규칙을 따르면서, 일관성 있게 처리된다는 것을 의미한다.

### 애그리게잇 경험 법칙
- 애그리게잇 설계의 4가지 기본 규칙은 다음과 같다.
1. 애그리게잇 경계 내에서 비즈니스 불변사항들을 보호하라.
2. 작은 애그리게잇을 설계하라
3. 오직 ID를 통해 다른 애그리게잇을 참고하라.
4. 결과적 일관성을 사용해 다른 애그리게잇을 갱신하라
- 위의 규칙들을 반드시 엄격하게 지키지 않아도 된다.
- DDD를 신중하게 적용할 때, 효과적으로 동작하는 애그리게잇을 설계할 수 있도록 도와주는 가이드로 볼 수 있다.

#### 애그리게잇 설계 규칙 1. 애그리게잇 경계 내에서 비즈니스 불변사항들을 보호하라.
- 규칙 1은 결과적으로 트랜잭션이 커밋될 떄 비즈니스의 일관성이 지켜지는 것에 기반을 두고, 애그리게잇 구성 요소를 결정해야 한다는 의미이다.
<img width="619" alt="스크린샷 2023-10-13 오후 4 48 07" src="https://github.com/daadaadaah/my-ddd/assets/60481383/623386c1-bcaa-4329-942c-1efd939508a6">

- 위 사례를 예시로 들어보면, Product는 트랜잭션 끝에 ProductBacklogItem 인스턴스로 구성되는 모든 것이 반드시 Product의 루트와 일관되게 처리되도록 설계한다.
- 또한, Sprint는 트랜잭션의 끝에 CommittedBacklogItem 인스턴스로 구성되는 모든 것이 반드시 Sprint 루트와 일관되게 처리되도록 설계한다. 


#### 애그리게잇 설계 규칙 2. 작은 애그리게잇을 설계하라
- 이 규칙은 각 애그리게잇의 메모리 사용량과 트랜잭션 범위가 비교적 작아야 함을 강조한다.  
<img width="619" alt="스크린샷 2023-10-13 오후 4 55 14" src="https://github.com/daadaadaah/my-ddd/assets/60481383/81a1122c-d0e6-4073-9c93-d74e6e0b7d91">

- 위 다이어그램에 표현된 애그리게잇은 작지 않다.
- 여기서, Product는 문자 그대로 BacklogItem 인스턴스들 그리고, Sprint의 가능한 가장 큰 모음을 담고 있다.
- 일반적으로 이런 설계 방식은 매우 나쁜 선택이다.
- 왜냐하면, 이런 모음들은 시간이 지나면서 1000여 개의 BacklogItem 인스턴스와 약 100여 개의 Release, Sprint 인스턴스로 엄청나게 크게 불어날 수 있기 때문이다.

- 하지만, 아래 다이어그램처럼, Product 애그리게잇을 4개의 애그리게잇으로 구성하는 형태로 분해할 수 있다.
<img width="612" alt="스크린샷 2023-10-13 오후 4 55 35" src="https://github.com/daadaadaah/my-ddd/assets/60481383/e31de5c2-8234-436a-84bf-a1b1ec2aa31d">

- 이들은 빠르게 로드되고, 더 작은 메모리를 차지하며, 가비지 컬렉션도 더 빠르다.
- 하지만, 가장 중요한 것은 이 애그리게잇들은 이전의 큰 클러스터의 Product 애그리게잇보다 훨씬 더 자주, 성공적인 트랜잭션을 수행할 것이라는 점이다.
- 이 규칙을 따르면, 연관된 각 작업이 한 명의 개발자가 관리할 수 있을만큼 작기 때문에, 각 애그리게잇이 좀 더 쉬워지는 부가적인 이득을 얻을 수 있으며, 테스트 또한 보다 더 쉬워질 것이다.

> 애그리게잇을 설계할 때 새겨둬야 할 사항 하나가 SRP라는 단일 책임 원칙이다.
- 만일 애그리게잇이 너무 많은 일을 한다면, 이는 SRP를 따르지 않는 것이고, 이후 애그리게잇의 크기에 대해 재논의할 가능성이 크다.
- 예를 들어, 만들고자 하는 Product가 스크럼 제품에 주안점을 두고 있는지, 아니면 다른 것도 함께 추구하는 것인지
- 즉, Product를 변경하는 이유가 더 나은 스크럼 제품을 만들기 위해서인지? 아니면 백로그 아이템, 릴리스, 스프린트를 관리하기 위해서인지? 에 대해 고민해보면, 답을 알 수 있다.
- 여기에서는 더 나은 스크럼 제품을 만들기 위해 Product를 바꿔야 한다는 목적에 초점을 둬야 한다.

#### 애그리게잇 설계 규칙 3. 오직 ID를 통해 다른 애그리게잇을 참고하라.
- 이러한 형태는 애그리게잇을 작게 유지하고, 동일한 트랜잭션 내에 여러 애그리게잇을 수정하려는 접근을 방지해준다.
- 이렇게 식별자을 통해서만 레퍼런스를 얻는 규칙의 장점은 다음과 같다.
1) 더 적은 메모리 요구와 리파지토리로부터의 빠른 로딩을 통해 애그리게잇 설계를 작고 효율적으로 유지할 수 있게 해준다.
2) 동일한 트랜잭션 내에 다른 애그리게잇을 수정하지 않는 규칙이 잘 지켜지도록 해준다.
3) 애그리게잇을 관계형 데이터베이스, 문서 데이터베이스, 키/밸류 리파지토리 그리고 데이터 그리드/패브릭과 같은 다른 형태의 저장 메커니즘으로도 쉽게 저장할 수 있다는 것이다.
    - 이는 MySQL 관계형 테이블, PostgresSQL이나 MongoDB, GemFire/Geode, Coherence 그리고 GigaSpaces와 같은 JSON 기반의 리파지토리 사용을 선택적으로 결정할 수 있다는 것을 의미한다. 

#### 애그리게잇 설계 규칙 4. 결과적 일관성을 사용해 다른 애그리게잇을 갱신하라
- BacklogItem은 Sprint와 연계되어 수행된다.
- 그래서, BacklogItem과 Sprint 모두 이것에 맞춰 설계가 이루어진다.
- 먼저, BacklogItem은 관여된 Sprint를 알아야 한다.
- 이는 BacklogItem의 상태가 해당 Sprint의 SprintID를 갖도록 정의하는 하나의 트랜잭션 안에서 관리된다.

> 결과적 일관성이 두럽게 느껴진다면
- 결과적 일관성을 사용함에 있어 엄청나게 힘든 점은 없지만, 실제 경험해보기 전까지는 결과적 일관성 사용에 대한 걱정이 있을 수도 있다.
- 그렇다고 해도 비즈니스에 의해 정의된 트랜잭션 경계에 따라 모델을 애그리게잇으로 분리시켜야 한다.
- 2개 이상의 애그리게잇을 단일한 데이터베이스 트랜잭션으로 묶어 처리하고 싶어 할 수도 있다.
- 이전에 이철머 커다란 트랜잭션을 처리했고, 성공했을 수도 있지만, 다른 모두를 위해 일관성 있게 사용할 필요가 있다.
- 이는 초기 단계부터 너무 거대한 처리를 만들지 않도록 해주는 기법이다.
- 이것이 애그리게잇을 사용하는 근본적인 이유는 아니지만, 결과적으로 트랜잭션 실패 경험을 줄여줄 수는 있을 것이다.





### 애그리게잇 모델링







## 6장. 도메인 이벤트와 전술적 설계












